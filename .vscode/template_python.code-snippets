{
	"solpy": {
		"prefix": "solpy",
		"body": [
			"if 1:",
			"    from typing import Any, Optional, List",
			"    from collections import Counter",
			"    from functools import cache",
			"    from heapq import heapify, heappop, heappushpop",
			"    from itertools import permutations",
			"    from math import comb, inf",
			"    from more_itertools import minmax, sieve",
			"",
			"lowbit = lambda x: x & -x",
			"",
			"fmax = lambda x, y: x if x > y else y",
			"fmin = lambda x, y: x if x < y else y",
			"",
			"MOD = 1_000_000_007",
			"",
			""
		]
	},
	"py": {
		"prefix": "py",
		"body": [
			"if 1:",
			"    from typing import Any, Optional, List",
			"    from collections import Counter",
			"    from functools import cache",
			"    from heapq import heapify, heappop, heappushpop",
			"    from itertools import permutations",
			"    from math import comb, inf",
			"    from more_itertools import minmax, sieve",
			"    import sys",
			"",
			"    input = lambda: sys.stdin.readline().strip()",
			"    fmax = lambda x, y: x if x > y else y",
			"    fmin = lambda x, y: x if x < y else y",
			"    lowbit = lambda x: x & -x",
			"    comb = cache(comb)",
			"",
			"    def I() -> str | Any:",
			"        return input()",
			"",
			"    def II() -> int:",
			"        return int(input())",
			"",
			"    def LI() -> List[str]:",
			"        return list(input().split())",
			"",
			"    def MII():",
			"        return map(int, input().split())",
			"",
			"    def LII() -> List[int]:",
			"        return list(map(int, input().split()))",
			"",
			"    MOD = 1_000_000_007",
			"",
		]
	},
	"pys": {
		"prefix": "pys",
		"body": [
			"if 1:",
			"    from typing import Any, Optional, List",
			"    from collections import Counter",
			"    from functools import cache",
			"    from heapq import heapify, heappop, heappushpop",
			"    from itertools import permutations",
			"    from math import comb, inf",
			"    from more_itertools import minmax, sieve",
			"    import sys",
			"",
			"    input = lambda: sys.stdin.readline().strip()",
			"    fmax = lambda x, y: x if x > y else y",
			"    fmin = lambda x, y: x if x < y else y",
			"    lowbit = lambda x: x & -x",
			"    comb = cache(comb)",
			"",
			"    def I() -> str | Any:",
			"        return input()",
			"",
			"    def II() -> int:",
			"        return int(input())",
			"",
			"    def LI() -> List[str]:",
			"        return list(input().split())",
			"",
			"    def MII():",
			"        return map(int, input().split())",
			"",
			"    def LII() -> List[int]:",
			"        return list(map(int, input().split()))",
			"",
			"    MOD = 1_000_000_007",
			"",
			"def solve():",
			"    $1",
			"    pass",
			"",
			"",
			"if __name__ == \"__main__\":",
			"    for _ in range(II()):",
			"        solve()",
			""
		]
	},
	"timer": {
		"prefix": "timer",
		"body": [
			"import time, sys",
			"",
			"",
			"def timer(func):",
			"    def wrapper(*args, **kwargs):",
			"        start_time = time.time()",
			"        result = func(*args, **kwargs)",
			"        end_time = time.time()",
			"        sys.stderr.write(f\"{func.__name__}: {end_time - start_time}s\\n\")",
			"        return result",
			"",
			"    return wrapper",
			"",
		]
	}
}