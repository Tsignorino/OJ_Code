# Atcoder ABC379    2024.11.9

感觉越来越不行了，ABC 连着三场炸裂了。这次只写了两道题，C 题一直都读错了题。。。。  
DE 不会。。。。。  
思维混沌，啊啊啊啊啊啊啊啊啊啊啊啊  

> 当两三次错相同样例的时候，看看是否读错题了

# LC Weekly 421   2024.10.27

这场真得感谢 Python 了，实在太方便了。不过第二题和第四题都没有想通怎么变换，第二题还是暴力过的，别人觉得比较典（学习第四题矩阵快速幂的解法）  
~~AI 坑我 5 分钟~~

# LC Weekly 420   2024.10.20

没有意识到 `最大真因数 * 最小质因数`，不过还是瞎搞出来了。  
第四题学习 dfs 时间戳（早在之前链式前向星的时候，就接触了时间戳，但是真没注意到。。。）  

# LC Weekly 417   2024.9.29

感觉昨天晚上不太适合写题，考虑到之前 Atc 打完之后 LC Biweekly 反应不过来，索性就打周赛好了，但是今天打的真是依托啊。。。  
~~（经典牢扣 2==4）~~  
第一题还好，直接暴力过了；第二题跟第三题一样都是滑窗，但是滑不出来，多指针滑窗现在生疏了（赛后看别人代码才意识到可以转换一下思路，就跟之前 Weekly 416 大致一样了）  
最后第二题还是暴力混过去的，不如写写 T4（不过赛时没有想到转换成二进制就感觉不应该，脑子不行了） ...

# Atcoder ABC373   2024.9.28

C 题真是幽默完了。  
D 题没写出来，建立反向边递归就好了（想了并查集，但是不会带权并查集；递归写的一团糟，想到建立反向边但是没写出来相应的递归）。  
E 题忘了考虑原来就比 `vec[i] + x` 大的人了，直接求和明显是错误的，不过最后二分的 check 还是写出来了。

# LC Weekly 416   2024.9.22

T3 T4 没滑出来。。。  
T2 直接二分，不过 `堆` 的思路挺巧的。

# LC Weekly 415   2024.9.15

昨晚上只会一道题，前些天还练了一点网格图，结果也没写出来。今天写出来三题，T2 不知道对不对，T3 用的自然溢出哈希，不敢提交。  
（还好没提交。。。。）

# Atcoder ABC371   2024.9.14

还行，正常写出五道题，感觉难度比之前低了一些。  
F 题题目挺好玩，感觉线段树可以，但是 `二分什么`，`怎么实现` 不清楚。  
G 题之前有一次类似的，不过没有理解原理，这个又做了一些改动。  

# LC Weekly 411   2024.8.18

T1 直接暴力，不知道有什么问题，T4 加大数据范围就没有什么思路。赛时 T3 写数学解，但是不清楚写出来的有哪些地方 bug（之后还发现了两个 bug，更不敢了），或者规律找得不对，又或者数字 7 的判断超时之类的，T2 dp也是很快写完不知道对不对，不敢交。
总之，对错，是否上分都不影响了，对了没上分就不要后悔，错了就狠狠窃喜。

赛后，T1 T2 无问题，T3 挂了（好多 bug），还好还好

# Atcoder ABC364   2024.8.17

B 真幽默。然后自己就幽默了。D，E 都没转过来弯。

# LC Weekly 408   2024.7.28

两题。。这一场被Python和C++来回切换搞麻了
第二题的时候VScode一直调试不出来，切到CLion发现之前折腾的CMake又出问题。。。最后发现 init 函数没有加括号执行
后面两题基本没看，赛后读了题也没什么思路。

# Atcoder ABC364   2024.7.27

Atcoder 写了前三题，C题还因为复制没改数组名WA了一场，B题纯粹模拟还直接跳过去耽误了一些时间，还因为 n 和 s.size() 搞混了，弄了很久
D题感觉可以写出来，但是晚上吃饭没心思了

# LC Weekly 406   2024.7.14

成功AK一次力扣，虽然最后一题是猜的，还是根据群友的一句聊天记录才发现自己没有给 vec 从大到小排序，第二题链表没写好，直接用哈希加数组莽过去了

# Atcoder ABC362   2024.7.13

基本速通ABC，但是D题有边权和点权，在dijkstra算法上面改了改，不过没有注意 `无向图` 这一条件，浪费了很长时间

# LC Biweekly 131   2024.5.25

1 题在性质上面犹豫了一下，没有直接写暴力，虽然最后还是先写暴力过了
3 题 WA 了三次，第一次因为 ump 对应的键没有找好，第二次因为 n 的值写错了，应该是 limit + 1，第三次是因为没有注意到数据范围，limit 是 1e9，用哈希过了

# ABC 355   2024.5.25

B 题 WA 了一次，flag 没有标记好（存在一定不行，不存在不一定行）
C 题没有理解好对角线，还有数组下标从 1 开始填数据不习惯，题目方格填充的数据从 0 开始更好写，没有意识到

# CF Div2   2024.5.17

A 题没有注意 a <= b <= c 这个条件，也没有观察到规律
B 题刚开始想的二分，觉得好像不对劲，然后暴力解超时，用线段树莽，还是超时，后来用二分 + 线段树过了，看别人是二分 + 按位枚举，之后再说吧
（为什么要在AC了之后再提交一次呢？得分只记录最后一次提交的时间，并且第二次AC之前还WA了一次，表现分直接扣了几百，算是长个记性）

# LC Weekly       2024.4.21

第一题、第二题学到了字母大小写的诸多技巧：
    判断大小写：
        ch >> 5 & 1
        ch & 32
    判断对应字符（不分大小写）：
        ch & 31

第四题：dijkstra：$dis[x] + W(xy) = dis[y]$
(可以正反跑两边 dijkstra，也可以后续进行 BFS、DFS)

最近图论最短路的比较多，考察了好几次 dijkstra，但是还是没有写出来
有几个困扰的点：
1. 怎么记录所有最短路的路径（标记：如何取消标记？记录路径：怎么去掉无效路径（死胡同、非最短路）？）
2. 找到路径之后，怎么对应更新 ans
   （可以在存图的时候记录 edges 下标）

可以从终点 n-1 出发，倒着 DFS 或 BFS，设当前在点 y，邻居为 x，边权为 w，
如果满足 $dis[x] + W(xy) = dis[y]$，则说明 x-y 这条边在 0~n-1 最短路上。

# LC Weekly       2024.4.14

第一题判断WA了四次。。。
第二题素数判断，埃氏筛板子每次都没有很好地直接运用。。。
第三题还是由AI点出来的二分，不过容斥原理没想到（感觉挺正常的思维啊，怎么回事？）
不过就算知道容斥原理，也很难想到去推广到多个数的情况，不知道怎么取枚举子集。

两题选手。。。

# 小白月赛 90     2024.4.5

> multiset 的 erase 数值删除会把相同的值都删掉！！

用 vec 二分卡着超时的界限 AC 不了，转成用 multiset 实现 “大根堆” 过了
（小根堆的话，每次要移除最大值，rbegin()无法作为参数传入，
* [2024.7.28] 可以 `prev(set.end())`

所以存入 b[i] 的相反数，传入 begin() 过了

* 可以 `multiset<int, greater<int>> set(b.begin(), b.begin() + k)`）

[E 题](https://ac.nowcoder.com/acm/contest/78306/E) 赛时总感觉前缀和作用不大，赛后看别人的代码，空间上好很多

# LC Weekly 391      2024.3.31

T4 没有思路，只会暴力剪枝，学习 `曼哈顿距离转切比雪夫距离`

# LC Weekly 390      2024.3.24

属于是对 ADT、KMP、Z函数、trie 不熟悉了。。。短暂的三题之后，回归两题  
第三题学到了有序集合 multiset，不过对懒删除堆还是不够了解；  
第四题重新认识字典树，把之前的板子删掉了（因为有必要根据题目书写，板子作用不大）

# LC Weekly 387      2024.3.10

（忘了Python怎么排序了。。。）
第三题理不清思路，写了一坨，数据范围比较小，直接暴搜，还好最后通过了。
第四题是划分型DP，继续学习新的知识！（到现在还没学。。）

# LC Weekly 387      2024.3.3

* 第一题学习到了 C++ insert 用法
* 第二题没有一下认识到二维前缀和，有些离谱，墨迹了太久，最后还 WA 了一次
* 第三题正难则反，按题意模拟写了一大堆，反向思考（看最多保留多少个格子不变）容易一些，另外也认识到，如果题目不限制 0，1，2 的话，可以考虑利用两个 cnt 的最大值和次大值
* 第四题因为没有意识到 insert 用法，没有写出来，赛后发现 Python 和 C++ 都可以正常通过，亏大了（不过肯定错解）  
手速场，三题选手，差一点四题，可能只有这样的题我才有可能四题，而且时间还不够用。。。

> 不过之后需要补一下第四题的 `树状数组`

# Round35     2024.3.3

* B 题相同的两两配对，配对不了输出 -1（可以考虑排序）
* C 题二分时要用 iter 减去 a[i] 的值，而不是减去 a.begin()，在这上面晕乎了
* D 题贪心，先查找哪些可以不修改（注意下标和值各自的作用）
* （E、F/G 题都不会。。。）  
F/G 题没搞清楚子序列的概念，还以为需要去掉重复结果，那题目就简单很多了

# LC Biweekly 125     2024.3.2

在第二题里面重新认识了优先队列（大根堆）  
当时比赛的时候看到两道图的题目，就不想写了，没想到第四题可以有一个跟 edges 数组一点关系都没有的解法

> 需要补一下第三题和第四题（尤其是第四题的脑筋急转弯）

# Round34     2024.2.25

* B 题犯了两个致命错误，首先用数组创建的哈希表没有初始化，其次数据输入没有读取完整就 return 了！！
```cpp
// 还有，初始化的时候，应该是
memset(a, 0, sizeof(a));
// 而不是
memset(a, 0, n);
```
（`[2024.5.18]` 不要用memset初始化，-1和0只是初始化的特殊情况）
* D 题思路：只会出现 111222 或者 222111 这两种情况，可以进行特判，分类讨论

> todo: 二分图
    E 题 https://ac.nowcoder.com/acm/contest/75766/E


# LC Weekly 385  2024.2.19

* 看到第一题，果断 Python，但是想着先看看后面的题再提交
* 第二题看着像是字典树，空间的话应该也是可以的，改了改就差不多
* 第三题晕了，没有想到方向向量，硬是模拟 8 种操作，在 '矩阵遍历' 和 '保存初值' 两个点上频繁出错，还在最后统计的时候 WA 了一次  
该死，最后前三题都对了，第二题没提交上去。。
（这是第二次离三题选手最近的一次了。）  
第三题好像也不用预处理素数，直接判断就好了，不过愣是没想到定义一个方向数组，蠢蠢地写了八个循环
* 第四题学到了 pair 方法，把前缀和后缀放在一起匹配

# LC Biweekly 124    2024.2.18

脑子短路，代码一点写不出来。第一题就看蒙了几分钟。

烦死字符串题了，第二题磨了好久才开始取用哈希表写。
让删除字符，只能想到把需要删除的字符改成未出现的字符，最后遍历的时候忽略掉，但是写的代码还是错误的（当然，是在比赛之后才试着提交了一下）
写了之后，总是感觉哈希表没有发挥太大作用，然后联想到要返回满足要求的字符串，需要进行字符出现次数的最大值（maxV）减 1 次的删除操作，
之后，前面出现次数等于 maxV 的字符，保留最后一个，其余字符全部删除，联想到可以从后往前遍历，于是顺利地解决了。

第三题看着像动态规划，写函数写了好久，函数第一次的执行和后面执行不一样，需要在第一次执行的时候确定一个 val，所以考虑独立出去一个函数，
主函数里面再重写一下函数即可，但是出现了一个致命问题没有被察觉。

`nums[l] + nums[r] == val + func(l + 1, r - 1, val)`

缝缝补补完之后，提交 WA 了，
然后趁着一段空闲，把之前瞎写的第一题用第三题的代码改了改（过了就行）
重新审视题目要求，发现当找到的两个数和不为 val 时就应该停止，重新写了函数，提交超时，但是 C++ 不知道怎么去写记忆化，没时间了

赛后，用 Python 写了一遍，WA 了，是因为没有将 bool 类型的值转成数值，强制转换后通过
（为什么我要选择C++呢！！！）


# Round33     2024.2.18

B题又被绕晕了。。。、
先算出来能煮几次，然后算一下每煮一次需要新打开几袋即可。
C题用指针模拟出来了，看别人题解也有用 dp 的，能力不够啊，不会。。
D题没有理清楚题意，忘记了可能出现多个重复数据的情况，改用 hashmap 凑合过了

# 小白月赛 87     2024.2.16

只写出了 A、B 两道题
A 题：判断正序遍历的时候谁先手拿，对应比较结果
B 题：变换思维，题目要求排序区间长度严格小于 n 的数组，那就记录原始数组头尾元素，与排序后的进行比较
C、D题模拟，不知道怎么写，E 题构造，无从下手。

赛后想法：  
 * F 题，看了看别人的代码，想到：与的结果不会变大，那只需要看异或和或的情况了，暴力？？  竟然过了，看来猜测没问题，不过需要注意 int 范围问题。  
 * B 题不需要排序，总之就是判断是否 “最大值在最后或者最小值在最前” 就可以  
 * E 题，b 数组全体加 1，减 1 不影响极差，可以定义 `b[1] = 0` 为基准，而后续加 1，减 1对极差没有影响，可以只考虑 `b[i] > 0`

> todo: 树状数组
    [G 题](https://ac.nowcoder.com/acm/contest/73854/G)，BIT 求逆序对、容斥求互质数对的个数
    